AOS.init({ once: true, // animation sirf ek baar scroll hone par duration: 1000 // default animation duration in ms }); /* Variables & elements */ const orbitArea = document.getElementById('orbitArea'); const earthOrbit = document.getElementById('earthOrbit'); const moonOrbit = document.getElementById('moonOrbit'); const earthOrbitLabel = document.getElementById('earthOrbitLabel'); const moonOrbitLabel = document.getElementById('moonOrbitLabel'); const sun = document.getElementById('sun'); const earth = document.getElementById('earth'); const moon = document.getElementById('moon'); const terminator = document.getElementById('terminator'); const countrySelect = document.getElementById('countrySelect'); const timeText = document.getElementById('timeText'); const statusText = document.getElementById('statusText'); /* Responsive sizing derived from computed styles */ function computeSizes() { const areaRect = orbitArea.getBoundingClientRect(); const cx = areaRect.width / 2; const cy = areaRect.height / 2; // orbit radius is 40% of smaller dimension or CSS var fallback const orbitR = Math.min(areaRect.width, areaRect.height) * 0.42; return { cx, cy, orbitR, areaRect }; } /* place an element at polar coords around center */ function place(el, cx, cy, angleDeg, radius) { // convert angleDeg where 0 deg = at right, increasing clockwise const a = (angleDeg) * Math.PI / 180; const x = cx + Math.cos(a) * radius; const y = cy + Math.sin(a) * radius; el.style.left = ${x - el.offsetWidth / 2}px; el.style.top = ${y - el.offsetHeight / 2}px; } /* status helper */ function getStatus(h) { if (h >= 5 && h < 9) return 'ðŸŒ… Morning'; if (h >= 9 && h < 17) return 'â˜€ï¸ Daytime'; if (h >= 17 && h < 20) return 'ðŸŒ‡ Evening'; return 'ðŸŒ™ Night'; } /* animation state */ let earthAngle = 0; // degrees, current orbital angle for earth around sun let earthTarget = null; // target angle when user selects country let orbitSpeed = 0.02; // degrees per ms baseline (will be scaled) let lastTime = performance.now(); /* initialize orbit visuals */ function updateOrbitRing() { const { cx, cy, orbitR, areaRect } = computeSizes(); // Update Earth's orbit earthOrbit.style.width = ${orbitR * 2}px; earthOrbit.style.height = ${orbitR * 2}px; earthOrbit.style.left = calc(50% - ${orbitR}px); earthOrbit.style.top = calc(50% - ${orbitR}px); // Position Earth's orbit label earthOrbitLabel.style.left = ${cx + orbitR + 10}px; earthOrbitLabel.style.top = ${cy}px; // Update moon orbit ring const moonOrbitR = orbitR * 0.28; moonOrbit.style.width = ${moonOrbitR * 2}px; moonOrbit.style.height = ${moonOrbitR * 2}px; } /* main render loop with smooth motion */ function frame(now) { const dt = now - lastTime; // ms lastTime = now; // baseline continuous motion (slow) earthAngle += orbitSpeed * dt; // degrees // if there's a target (user selected), ease toward it instead of free spin if (earthTarget !== null) { // compute shortest angular delta let diff = ((earthTarget - earthAngle + 540) % 360) - 180; // -180..180 // ease factor: adjust to taste const ease = 0.0045 * dt; // scaled by dt for frame-rate independence earthAngle += diff * Math.min(1, ease); } // keep angle in 0-360 earthAngle = (earthAngle + 3600) % 360; // compute sizes and place earth+moon const { cx, cy, orbitR } = computeSizes(); // Earth orbits sun at radius orbitR place(earth, cx, cy, earthAngle, orbitR); // Moon orbits Earth at smaller radius and faster speed const moonOrbitR = orbitR * 0.28; const moonAngle = earthAngle * 3 + ((performance.now() / 80) % 360); // relative faster // Position moon orbit ring around Earth const earthRect = earth.getBoundingClientRect(); const earthCenterX = earthRect.left + earthRect.width / 2 - orbitArea.getBoundingClientRect().left; const earthCenterY = earthRect.top + earthRect.height / 2 - orbitArea.getBoundingClientRect().top; moonOrbit.style.left = ${earthCenterX - moonOrbitR}px; moonOrbit.style.top = ${earthCenterY - moonOrbitR}px; // Position moon orbit label moonOrbitLabel.style.left = ${earthCenterX + moonOrbitR + 10}px; moonOrbitLabel.style.top = ${earthCenterY}px; // Position moon const a = moonAngle * Math.PI / 180; const mx = earthCenterX + Math.cos(a) * moonOrbitR; const my = earthCenterY + Math.sin(a) * moonOrbitR; moon.style.left = ${mx - moon.offsetWidth / 2}px; moon.style.top = ${my - moon.offsetHeight / 2}px; // rotate terminator so shadow faces AWAY from sun direction relative to earth // Sun is at center; vector from earth -> sun is (-cos, -sin) of earthAngle; we rotate terminator to earthAngle+180 const terminatorAngle = (earthAngle + 180) % 360; terminator.style.transform = rotate(${terminatorAngle}deg); // Sun is already centered with CSS (left:50%, top:50%, transform:translate(-50%,-50%)) // No need to reposition it in JavaScript requestAnimationFrame(frame); } /* update info box for a selected country or default (local) */ function updateInfoBoxForOffset(offset) { const now = new Date(); if (isNaN(offset)) { // show user's local time timeText.textContent = now.toTimeString().slice(0, 5); statusText.textContent = getStatus(now.getHours() + now.getMinutes() / 60); earthTarget = null; // remove forced orientation return; } // compute local time for offset (offset in hours, can be fractional) const utc = now.getTime() + now.getTimezoneOffset() * 60000; const local = new Date(utc + offset * 3600000); const localHours = local.getHours() + local.getMinutes() / 60 + local.getSeconds() / 3600; timeText.textContent = local.toTimeString().slice(0, 5); statusText.textContent = getStatus(localHours); // target angle: map localHours -> position on orbit so that local noon (~12:00) faces sun (i.e., earth near sun) // We compute: when localHour == 12 => Earth should be at angle that places that longitude facing sun. // Simple mapping: targetAngle = (localHours / 24) * 360 // This is illustrative â€” it positions planet along orbit consistent with the local hour. const target = (localHours / 24) * 360; // use opposite so that 12:00 (noon) places Earth's day side to sun: adjust by 180 if needed // After testing: better to set earthTarget = target (gives intuitive positions) earthTarget = target; } /* handle country selection */ countrySelect.addEventListener('change', () => { const offset = parseFloat(countrySelect.value); updateInfoBoxForOffset(offset); // subtle visual emphasis earth.style.transition = 'transform 1.1s cubic-bezier(.2,.9,.2,1)'; moon.style.transition = 'left 1.1s cubic-bezier(.2,.9,.2,1), top 1.1s cubic-bezier(.2,.9,.2,1)'; setTimeout(() => { earth.style.transition = 'transform 1.2s linear'; moon.style.transition = ''; }, 1200); }); /* initial layout adjustments */ function init() { // set CSS variables scale based on viewport const vw = Math.min(window.innerWidth, 980); // scale orbitRadius/earth size for smaller screens if (window.innerWidth < 480) { document.documentElement.style.setProperty('--orbit-radius', '120px'); document.documentElement.style.setProperty('--earth-size', '52px'); document.documentElement.style.setProperty('--moon-size', '18px'); document.documentElement.style.setProperty('--sun-size', '64px'); } else if (window.innerWidth < 720) { document.documentElement.style.setProperty('--orbit-radius', '140px'); document.documentElement.style.setProperty('--earth-size', '56px'); document.documentElement.style.setProperty('--moon-size', '20px'); document.documentElement.style.setProperty('--sun-size', '72px'); } else { document.documentElement.style.setProperty('--orbit-radius', '170px'); document.documentElement.style.setProperty('--earth-size', '64px'); document.documentElement.style.setProperty('--moon-size', '22px'); document.documentElement.style.setProperty('--sun-size', '84px'); } updateOrbitRing(); // start animation loop lastTime = performance.now(); requestAnimationFrame(frame); // start an interval to refresh info when no country selected (show local) setInterval(() => { if (!countrySelect.value) updateInfoBoxForOffset(NaN); }, 1000); } /* keep orbit visuals updated on resize */ window.addEventListener('resize', () => { updateOrbitRing(); }); // Initialize when modal is shown document.getElementById('solarSystemModal').addEventListener('shown.bs.modal', function () { init(); });